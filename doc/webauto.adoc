= Web scenarios browser automation


== Knowledge needed to understand this doc
* YAML basics (look https://www.w3.org/TR/xpath/[here] or on the https://en.wikipedia.org/wiki/YAML#Basic_components[wiki page])
* what is scenario, step, step definition

== Abstract
The "web rules" represent whole structure we are using for web automation.
The web rules were implemented for several reasons:

* separate web automation from the Cucushift core.
* allow cross-browser && cross-version testing with one feature file.
* make Scenarios maintenance easier when new releases coming.
* provide neat way of communication with browser.

At the root level of the `*.xyaml` file we do always have an `action` rule, which could
consist of the following rules:

* `action:`
* `url:`
* `element:`/`elements:`
* `scripts:`

Any combination of rules could be used to locate required elements on the web
page and perform operations on it.

== Web Rules
=== Action
Each action has a `name`. Only by this name action could be
called from the `*.feature` file. The action with name `empty_action`
could be created as:
`empty_action: {}`

Reusing of existing actions or combining own is possible with `action` keyword:

[source,yaml]
----
parent_web_rule:
  action: child_web_rule_1
  action: child_web_rule_2
child_web_rule_1:
  url: /console
child_web_rule_2:
  element:
    selector:
      text: Login
----

=== URL redirection
URL can be opened with the following rule:

[source,yaml]
----
open_console_url:
  url: /console
----

If provided url is relative, then an absolute URL will be constructed based on the `Web4Cucumber#base_url`.
For console cases, this will be automatically set to `Environment#web_console_url`.
For browsers created for testing images or other purposes, then the step creating the browser
should make sure to set correct `base_url` in the `Web4Cucumber` constructor.
You can check `I have a browser with:` step for an example how to do so.

=== Elements
To select an element on web page `element` and following `selector` should be
provided.

[source,yaml]
----
select_single_element:
  element:
    selector:
      text: hello world
----

If there is need to select multiple elements, then `elements` and list
of `selector`s can be provided:

[source,yaml]
----
select_multiple_elements:
  elements:
  - selector:
      text: hello
  - selector:
      text: world
----

This is nicer but equivalent in function to:

[source,yaml]
----
select_multiple_elements:
  element:
    selector:
      text: hello
  element:
    selector:
      text: world
----

Following element rules could be used to select and use an element:

==== `selector:`
To locate required element on the page various selectors could be used. General
selectors listed in the http://www.rubydoc.info/gems/watir-webdriver/0.9.1/Watir/ElementLocator#WD_FINDERS-constant[WD_FINDERS] constant.
HTML element property selectors listed https://github.com/watir/watir/blob/master/lib/watir/elements/html_elements.rb#L4-L94[here] and in
https://github.com/watir/watir/blob/master/lib/watir/locators/element/selector_builder.rb#L6[RE].
Example with `xpath:` selector:

[source,yaml]
----
rule:
  element:
    selector:
      xpath: //body
----

If the element can't be found with any of options above, JavaScript code
could be used:

[source,yaml]
----
rule:
  element:
    selector: |
      return document.getElementsByTagName("input");
    type: js
----

==== `type:`
Subtype of the element could be specified. Currently supported types are listed
in the https://github.com/openshift/cucushift/blob/v3/lib/webauto/web4cucumber.rb#L13-L28[FUNMAP] constant.

==== `op:`
After the element was successfully found `click`,`hover`,`clear`,`set`,
`send_keys`,`drag_and_drop_by`,`select_value` or `append` operations could be
performed:

[source,yaml]
----
rule:
  element:
    selector:
      xpath: //input
    op: send_keys <value>
----

the `op` which could be performed on the element depends on the element type.
Full picture of `element_type` - `op` —Åorrespondence can be found in the
https://github.com/openshift/cucushift/blob/v3/lib/webauto/web4cucumber.rb#L391-L429[source].

==== `missing:`
**default:false**

This option can be used for negative checks. When you need to make sure that
particular element can**not** be found on the page.

WARNING: Be aware that this option could give *false positive result* when the
page is not loaded completely. Don't use this option right after page
redirection took place.

==== `optional:`
**default:false**

With this property web rule will not fail when requested element was not found.

==== `timeout:`
**default:10**

Set maximum number of seconds to wait for the element before fail.

=== JS code
If required actions can't  be implemented with standard ways listed above, then
**JavaScript** code could be executed on the web page:

[source,yaml]
----
run_js_code:
  scripts:
  - command: |
        console.log("Nice")
        return true;
    expect_result: true
----

Make sure, that your command return `true`/`false` value and `expect_result:`
field exists.
There are two rules to run JavaScript code

==== `command:`
The JavaScript code could be placed inline in the `*.xyaml` file.

==== `file:`
This option take as a parameter name of the JavaScript file located in the
`/lib/rules/web/snippets/` directory. The `snippets` directory can be specified in the `Web4Cucumber` constructor.

=== Parameters
To make web rule widely usable for many Scenarios there is an option to provide
parameters within the table from the step:

[source,yaml]
----
| tab_name     | fromFile |
| project_name | xxxxx    |
----

In the web rule, provided parameter will be replaced by <key>:

[source,yaml]
----
goto_dc_tab:
  url: /console/project/<project_name>/create?tab=<tab_name>
----

== How to call the web rule from Scenario?
There are two common ways to call web rules from `*.feature` file:

* without parameters:

`I run the :web_rule_name web console action`

* with parameters:

[source,yaml]
----
I perform the :web_rule_name web console action with:
  | param | value |
----

== Where can I find all the web rules?

All existing web rules stored under the `lib/rules/web/console/<version>/`
directory. Rules will be taken from appropriate version folder, depending on
the environment version. Make sure to create new web rules for each version
automated test case could run on.

== XYAML vs YAML

XYAML format allows us to use multiple rules in a single action with the same
key, which will be parsed as an `Array` rather than a `Hash` with YAML:

[source,yaml]
----
parent_action:
  action: first
  action: second
  element: {...}
  element: {...}
----

As YAML, XYAML supports anchoring. Be aware that anchors work only in the same
file and there is no magic(https://developer.mozilla.org/en-US/docs/Glossary/Hoisting[hoisting]) in the XYAML: first - declare, then - use:

[source,yaml]
----
# this would work
action:
  element: &anchor
    xpath: ...
another_action:
  element:
    <<: *anchor

# this wouldn't
another_action:
  element:
    <<: *anchor
action:
  element: &anchor
    xpath: ...
----

== Good practices

* Don't duplicate the rules!
* Rule name should be unique, meaningful and short.
* Always try to write unique xpath, which will select only one element.
* Avoid using `Then the step should fail` for negative tests.
* Use `$x("<xpath expression>")` in browser debug console to test if we could find specific element.
* Use a simple ruby code `require 'yaml';YAML::load_file("<web_rule_file_path>")` to
check whether the changed `*.xyaml` file has valid format.
* To see all occurrences of specific web rule in the project use `grep -rnw '<project_path>' -e "<web_rule_name>"`.
* Try to be aware of any changes in this doc :D

== FAQ

* Q: Could you explain why we should avoid using `Then the step should fail` step for negative tests?
** A: When we are trying to check if element is missing on the page we need to wait for default timeout before the rule will fail. This was one of the reason to include `missing:` option.

* Q: Why do we need to create an empty actions in web auto?
** A: Our Scenarios in *.feature files are permanent for all version, but our web rules separated by version folder. Intention was to put all possible checks and operations which could change with upcoming releases to the web rules. So when we have new release we could just change web rules in appropriate folder and left Scenario untouched(so it works for previous version fine without any additional changes). Sometimes it happens that in new release we don't need action which was performed for previous releases, in this case we could left this action empty(If we'll simply delete this action, then Scenario will fail cause it couldn't find this action). For example look https://github.com/openshift/cucushift/search?utf8=%E2%9C%93&q=save_updated_env_value&type=[here]. We had separated "save button" for each env value in the second version, but when the editor was changed and this action is useless, so we just replaced the action content with {}.
